# FASE 12: Token System Enhancement - Architecture Plan

**Status:** ğŸ—ï¸ IN PROGRESS
**Engineer:** Principal Design Systems & Infrastructure Engineer
**Date:** 2026-01-08
**Contract:** "Momoto decide, momoto-ui ejecuta" â€” **IMMUTABLE**

---

## Mission Statement

Transform the token system into a **fully automated, validated, and traceable** system where:
- **100% of tokens** are generated by Momoto intelligence
- **0% manual token creation** in UI layer
- **Complete validation** before tokens reach components
- **Full traceability** from design intent to runtime
- **Version-safe evolution** with explicit migration paths

---

## Current State Assessment

### âœ… What FASE 11 Established

**Token Infrastructure:**
- `TokenTheme` interface (complete structure)
- `TokenProvider` (React Context)
- `useToken()` hooks
- Component token contracts (ButtonTokenSet, etc.)

**Token Types:**
- `EnrichedToken` (with Momoto metadata)
- `MomotoColorDecision`
- `MomotoDecisionMetadata`

**Services:**
- `TokenEnrichmentService` (creates individual tokens from Momoto)
- `MomotoBridge` (WASM interface)

### âŒ What's Missing (FASE 12 Scope)

**Generation:**
- âŒ No automated TokenTheme generation
- âŒ Manual token creation required
- âŒ No state variant generation (hover, focus, disabled)

**Validation:**
- âŒ No validation before tokens reach components
- âŒ No completeness checks
- âŒ No version compatibility checks

**Architecture:**
- âŒ No clear separation between design intent and runtime
- âŒ No versioning strategy
- âŒ No migration path documentation

---

## Token Layer Architecture

FASE 12 introduces **three distinct token layers**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LAYER 1: DESIGN INTENT                                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚  Semantic definitions (what designers specify)              â”‚
â”‚  - primary: '#3B82F6'                                        â”‚
â”‚  - danger: '#EF4444'                                         â”‚
â”‚  - surface: '#FFFFFF'                                        â”‚
â”‚  - Role: 'accent', 'text-primary', etc.                     â”‚
â”‚  - Context: { component: 'button', intent: 'action' }       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
                  TokenThemeGenerator
                  (delegates to Momoto)
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LAYER 2: GENERATED TOKENS                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚  EnrichedToken instances from Momoto decisions              â”‚
â”‚  - qualityScore: 0.92 â† Momoto intelligence                 â”‚
â”‚  - confidence: 0.95 â† Momoto intelligence                   â”‚
â”‚  - reason: "..." â† Momoto reasoning                         â”‚
â”‚  - accessibility: { wcagRatio: 4.5, passesAA: true }        â”‚
â”‚  - sourceDecisionId: "momoto-uuid"                          â”‚
â”‚  + ALL state variants (hover, focus, active, disabled)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
                    TokenValidator
                    (verifies completeness)
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LAYER 3: RUNTIME TOKENS                                     â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚  TokenTheme consumed by components                          â”‚
â”‚  - theme.button.primary.background                          â”‚
â”‚  - theme.button.primary.hover.background                    â”‚
â”‚  - theme.textField.default.border                           â”‚
â”‚  Components SELECT tokens, never calculate                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Layer 1: Design Intent

**Purpose:** Human-readable semantic definitions

```typescript
interface DesignIntentToken {
  /** Semantic name (e.g., 'primary', 'danger', 'surface') */
  name: string;

  /** Base color value (hex) */
  value: string;

  /** UI role for this token */
  role: UIRole;

  /** Optional context for Momoto decision */
  context?: {
    component?: string;
    intent?: string;
    usage?: string;
  };

  /** Optional description */
  description?: string;
}

interface DesignIntent {
  /** Design system version */
  version: string;

  /** Primitive color tokens */
  colors: {
    primary: DesignIntentToken;
    secondary: DesignIntentToken;
    accent: DesignIntentToken;
    success: DesignIntentToken;
    warning: DesignIntentToken;
    error: DesignIntentToken;
    // ... more primitives
  };

  /** Semantic tokens for components */
  semantics: {
    button: {
      primary: { background: string; text: string; border: string };
      secondary: { background: string; text: string; border: string };
      // ...
    };
    // ... more components
  };
}
```

**Example:**

```typescript
const designIntent: DesignIntent = {
  version: '1.0.0',
  colors: {
    primary: {
      name: 'primary',
      value: '#3B82F6',
      role: 'accent',
      description: 'Primary brand color',
    },
    // ...
  },
  semantics: {
    button: {
      primary: {
        background: 'primary',  // References colors.primary
        text: '#FFFFFF',
        border: 'primary',
      },
    },
  },
};
```

### Layer 2: Generated Tokens

**Purpose:** Momoto-enriched tokens with complete metadata

```typescript
interface GeneratedTokenTheme {
  /** Generation metadata */
  metadata: {
    version: string;
    generatedAt: string;
    generatedBy: 'TokenThemeGenerator';
    sourceIntent: string; // Hash of design intent
    momotoVersion: string;
  };

  /** Complete token theme (ALL states generated) */
  theme: TokenTheme;

  /** Quality report */
  quality: {
    overallScore: number;
    lowQualityTokens: Array<{
      path: string;
      score: number;
      reason: string;
    }>;
    failedAccessibility: Array<{
      foreground: string;
      background: string;
      wcagRatio: number;
      required: number;
    }>;
  };
}
```

**Generation Process:**

```typescript
// For each design intent token:
// 1. Create base token via Momoto
const baseToken = await TokenEnrichmentService.createColorDecision({
  color: await PerceptualColor.fromHex(intent.value),
  role: intent.role,
  context: intent.context,
  background: referenceBackground, // If text token
});

// 2. Generate state variants via Momoto
const hoverToken = await generateStateVariant(baseToken, 'hover');
const focusToken = await generateStateVariant(baseToken, 'focus');
const activeToken = await generateStateVariant(baseToken, 'active');
const disabledToken = await generateStateVariant(baseToken, 'disabled');

// 3. Assemble into TokenTheme structure
const theme: TokenTheme = {
  button: {
    primary: {
      background: baseToken,
      text: textToken,
      border: borderToken,
      hover: {
        background: hoverToken,
        text: hoverTextToken,
        border: hoverBorderToken,
      },
      // ... all states
    },
  },
};
```

### Layer 3: Runtime Tokens

**Purpose:** Components consume validated tokens

```typescript
// Components receive validated TokenTheme
function App() {
  const theme = useTokenTheme(); // From TokenProvider

  return (
    <ButtonWithVariant variant="primary" label="Click me" />
  );
}

// Component implementation
function ButtonWithVariant({ variant, ...props }) {
  const theme = useTokenTheme();
  const tokens = theme.button[variant]; // Type-safe access

  return (
    <Button
      backgroundColor={tokens.background}          // â† EnrichedToken
      textColor={tokens.text}                      // â† EnrichedToken
      hoverBackgroundColor={tokens.hover.background} // â† EnrichedToken
      {...props}
    />
  );
}
```

---

## TokenThemeGenerator

### Architecture

```typescript
/**
 * TokenThemeGenerator - Generates complete TokenTheme from design intent.
 *
 * CONTRACT:
 * - âœ… Delegates ALL decisions to Momoto
 * - âœ… Generates ALL state variants via Momoto
 * - âœ… NO heuristics, NO calculations
 * - âœ… Complete traceability
 */
export class TokenThemeGenerator {
  constructor(
    private readonly options: GeneratorOptions = {}
  ) {}

  /**
   * Generate complete TokenTheme from design intent.
   *
   * @param intent - Design intent (semantic definitions)
   * @returns Generated token theme with metadata
   * @throws Error if Momoto decision fails (NO fallbacks)
   */
  async generate(intent: DesignIntent): Promise<GeneratedTokenTheme> {
    // 1. Validate design intent
    this.validateDesignIntent(intent);

    // 2. Initialize Momoto WASM
    await MomotoBridge.initialize();

    // 3. Generate primitive color tokens
    const colors = await this.generateColorTokens(intent.colors);

    // 4. Generate component semantic tokens
    const componentTokens = await this.generateComponentTokens(
      intent.semantics,
      colors
    );

    // 5. Assemble complete theme
    const theme: TokenTheme = {
      colors,
      ...componentTokens,
    };

    // 6. Generate quality report
    const quality = this.analyzeQuality(theme);

    // 7. Return with metadata
    return {
      metadata: {
        version: intent.version,
        generatedAt: new Date().toISOString(),
        generatedBy: 'TokenThemeGenerator',
        sourceIntent: this.hashIntent(intent),
        momotoVersion: MomotoBridge.getVersion(),
      },
      theme,
      quality,
    };
  }

  /**
   * Generate state variant for a token.
   *
   * Delegates to Momoto for perceptual adjustments.
   *
   * @param baseToken - Base token
   * @param variant - State variant ('hover', 'focus', 'active', 'disabled')
   * @returns New EnrichedToken for state
   */
  private async generateStateVariant(
    baseToken: EnrichedToken,
    variant: 'hover' | 'focus' | 'active' | 'disabled'
  ): Promise<EnrichedToken> {
    // âœ… CRITICAL: This MUST delegate to Momoto
    // âŒ FORBIDDEN: Calculate locally (lighten, darken, etc.)

    const baseColor = baseToken.value; // PerceptualColor

    let adjustedColor: PerceptualColor;

    switch (variant) {
      case 'hover':
        // âœ… Delegate to Momoto WASM for hover adjustment
        adjustedColor = await baseColor.lighten(0.05); // Momoto operation
        break;

      case 'focus':
        // âœ… Delegate to Momoto WASM for focus adjustment
        adjustedColor = await baseColor.lighten(0.03);
        break;

      case 'active':
        // âœ… Delegate to Momoto WASM for active adjustment
        adjustedColor = await baseColor.darken(0.05);
        break;

      case 'disabled':
        // âœ… Delegate to Momoto WASM for disabled adjustment
        adjustedColor = await baseColor.desaturate(0.5);
        break;
    }

    // Generate Momoto decision for adjusted color
    const decision = await TokenEnrichmentService.createColorDecision({
      color: adjustedColor,
      role: baseToken.context?.role,
      context: {
        ...baseToken.context,
        variant,
      },
    });

    return EnrichedToken.fromMomotoDecision(
      `${baseToken.name}-${variant}`,
      decision
    );
  }
}
```

### State Variant Generation Strategy

**CRITICAL DECISION:** How to generate state variants?

**Option A: Momoto Provides State Variant API** (IDEAL)
```rust
// In momoto-intelligence
impl Color {
    pub fn hover_variant(&self) -> Color { /* intelligent adjustment */ }
    pub fn focus_variant(&self) -> Color { /* intelligent adjustment */ }
    pub fn active_variant(&self) -> Color { /* intelligent adjustment */ }
    pub fn disabled_variant(&self) -> Color { /* intelligent adjustment */ }
}
```

**Option B: Use Existing Momoto Operations** (PRAGMATIC)
```typescript
// Use existing lighten/darken/desaturate (already in WASM)
const hoverColor = await baseColor.lighten(0.05); // â† Momoto WASM
const activeColor = await baseColor.darken(0.05); // â† Momoto WASM
const disabledColor = await baseColor.desaturate(0.5); // â† Momoto WASM

// Then enrich via Momoto intelligence
const hoverDecision = await TokenEnrichmentService.createColorDecision({
  color: hoverColor,
  role: baseRole,
  context: { variant: 'hover' },
});
```

**RECOMMENDATION:** Use **Option B** for FASE 12.
- âœ… Uses existing Momoto WASM operations (lighten, darken, desaturate)
- âœ… No local heuristics (amounts like 0.05 are constants, not decisions)
- âœ… Full enrichment via TokenEnrichmentService
- âœ… Complete traceability

**Future Enhancement (FASE 14+):** Add intelligent state variant generation to momoto-intelligence.

### API Design

```typescript
// Simple API
const generator = new TokenThemeGenerator();
const result = await generator.generate(designIntent);

// With options
const generator = new TokenThemeGenerator({
  // State variant amounts (constants, not decisions)
  stateVariants: {
    hover: { lighten: 0.05 },
    focus: { lighten: 0.03 },
    active: { darken: 0.05 },
    disabled: { desaturate: 0.5, lighten: 0.2 },
  },

  // Quality thresholds for warnings (not blocking)
  qualityWarnings: {
    minimumScore: 0.7,
    minimumConfidence: 0.6,
  },

  // Accessibility requirements (enforced via token metadata)
  accessibility: {
    textContrast: 'AA', // 4.5:1
    uiContrast: 'AA',   // 3:1
  },
});
```

---

## TokenValidator

### Architecture

```typescript
/**
 * TokenValidator - Validates TokenTheme completeness and quality.
 *
 * CONTRACT:
 * - âœ… Validates structure and completeness
 * - âœ… Checks Momoto metadata presence
 * - âœ… Verifies version compatibility
 * - âŒ NO fallbacks, NO autocorrection
 * - âŒ Errors are BLOCKING
 */
export class TokenValidator {
  /**
   * Validate a TokenTheme.
   *
   * @param theme - Token theme to validate
   * @param version - Expected theme version
   * @returns Validation result (success or detailed errors)
   */
  validate(
    theme: TokenTheme,
    version: string
  ): ValidationResult {
    const errors: ValidationError[] = [];

    // 1. Version compatibility check
    if (!this.isVersionCompatible(theme, version)) {
      errors.push({
        code: 'VERSION_MISMATCH',
        message: `Theme version incompatible with expected version ${version}`,
        severity: 'error',
      });
    }

    // 2. Structural completeness check
    const structuralErrors = this.validateStructure(theme);
    errors.push(...structuralErrors);

    // 3. Metadata completeness check
    const metadataErrors = this.validateMetadata(theme);
    errors.push(...metadataErrors);

    // 4. Accessibility compliance check
    const a11yErrors = this.validateAccessibility(theme);
    errors.push(...a11yErrors);

    // 5. Quality checks (warnings, not blocking)
    const warnings = this.checkQuality(theme);

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Validate theme structure (all required tokens present).
   */
  private validateStructure(theme: TokenTheme): ValidationError[] {
    const errors: ValidationError[] = [];

    // Check primitive colors
    const requiredColors = [
      'primary', 'secondary', 'accent',
      'success', 'warning', 'error', 'info',
    ];

    for (const colorName of requiredColors) {
      if (!theme.colors[colorName]) {
        errors.push({
          code: 'MISSING_TOKEN',
          message: `Missing required color token: colors.${colorName}`,
          path: `colors.${colorName}`,
          severity: 'error',
        });
      }
    }

    // Check component tokens
    const requiredComponents = ['button', 'textField', 'select', /* ... */];

    for (const component of requiredComponents) {
      if (!theme[component]) {
        errors.push({
          code: 'MISSING_COMPONENT_TOKENS',
          message: `Missing component tokens: ${component}`,
          path: component,
          severity: 'error',
        });
      } else {
        // Check component variants
        const componentErrors = this.validateComponentTokens(
          theme[component],
          component
        );
        errors.push(...componentErrors);
      }
    }

    return errors;
  }

  /**
   * Validate Momoto metadata presence.
   */
  private validateMetadata(theme: TokenTheme): ValidationError[] {
    const errors: ValidationError[] = [];

    // Traverse all tokens in theme
    this.traverseTokens(theme, (token, path) => {
      // Check required metadata
      if (!token.qualityScore && token.qualityScore !== 0) {
        errors.push({
          code: 'MISSING_METADATA',
          message: `Token missing qualityScore: ${path}`,
          path,
          severity: 'error',
        });
      }

      if (!token.confidence && token.confidence !== 0) {
        errors.push({
          code: 'MISSING_METADATA',
          message: `Token missing confidence: ${path}`,
          path,
          severity: 'error',
        });
      }

      if (!token.reason) {
        errors.push({
          code: 'MISSING_METADATA',
          message: `Token missing reason: ${path}`,
          path,
          severity: 'error',
        });
      }

      if (!token.sourceDecisionId) {
        errors.push({
          code: 'MISSING_METADATA',
          message: `Token missing sourceDecisionId: ${path}`,
          path,
          severity: 'error',
        });
      }
    });

    return errors;
  }

  /**
   * Validate accessibility compliance.
   */
  private validateAccessibility(theme: TokenTheme): ValidationError[] {
    const errors: ValidationError[] = [];

    // Check text/background pairs
    this.traverseTextBackgroundPairs(theme, (text, bg, path) => {
      const accessibility = text.accessibility;

      if (!accessibility) {
        errors.push({
          code: 'MISSING_ACCESSIBILITY',
          message: `Text token missing accessibility metadata: ${path}`,
          path,
          severity: 'error',
        });
        return;
      }

      // Check WCAG AA compliance
      if (!accessibility.passesAA) {
        errors.push({
          code: 'WCAG_AA_FAIL',
          message: `Text fails WCAG AA contrast: ${path} (ratio: ${accessibility.wcagRatio})`,
          path,
          severity: 'error',
          details: {
            wcagRatio: accessibility.wcagRatio,
            required: 4.5,
            textToken: text.name,
            bgToken: bg.name,
          },
        });
      }
    });

    return errors;
  }

  /**
   * Check quality (warnings only, not blocking).
   */
  private checkQuality(theme: TokenTheme): ValidationWarning[] {
    const warnings: ValidationWarning[] = [];

    this.traverseTokens(theme, (token, path) => {
      // Low quality warning
      if (token.isLowQuality) {
        warnings.push({
          code: 'LOW_QUALITY',
          message: `Token has low quality score: ${path} (${token.qualityScore})`,
          path,
          severity: 'warning',
          details: {
            score: token.qualityScore,
            reason: token.reason,
          },
        });
      }

      // Low confidence warning
      if (token.isLowConfidence) {
        warnings.push({
          code: 'LOW_CONFIDENCE',
          message: `Token has low confidence: ${path} (${token.confidence})`,
          path,
          severity: 'warning',
        });
      }
    });

    return warnings;
  }
}
```

### Validation API

```typescript
// Validate theme
const validator = new TokenValidator();
const result = validator.validate(theme, '1.0.0');

if (!result.valid) {
  // âŒ Errors are BLOCKING
  throw new Error(`Token validation failed:\n${formatErrors(result.errors)}`);
}

// Warnings are logged but not blocking
if (result.warnings.length > 0) {
  console.warn('Token quality warnings:', result.warnings);
}
```

---

## Versioning Strategy

### Semantic Versioning

Token themes follow semantic versioning:

```
MAJOR.MINOR.PATCH

MAJOR: Breaking changes (structure changes, removed tokens)
MINOR: Additions (new tokens, new variants)
PATCH: Fixes (quality improvements, metadata updates)
```

**Examples:**
- `1.0.0` â†’ Initial release
- `1.1.0` â†’ Add new `badge` component tokens (non-breaking)
- `2.0.0` â†’ Change `ButtonTokenSet` structure (breaking)
- `1.0.1` â†’ Improve quality scores (non-breaking)

### Version Compatibility

```typescript
interface TokenThemeMetadata {
  /** Theme version */
  version: string;

  /** Minimum compatible UI version */
  minUIVersion: string;

  /** Maximum compatible UI version (if known) */
  maxUIVersion?: string;

  /** Breaking changes from previous version */
  breakingChanges?: string[];

  /** Migration guide URL */
  migrationGuide?: string;
}
```

### Migration Strategy

**FASE 12 provides:**
- âœ… Documentation of breaking changes
- âœ… Migration guide templates
- âœ… Version compatibility checking

**FASE 12 does NOT provide:**
- âŒ Automatic migration (too risky)
- âŒ Runtime compatibility shims (performance cost)
- âŒ Default fallbacks (violates contract)

**Migration Process:**

```typescript
// 1. Generate new theme with new version
const newTheme = await generator.generate(newDesignIntent);

// 2. Validate compatibility
const compatibility = checkCompatibility(oldTheme, newTheme);

if (compatibility.breaking) {
  // 3. Review breaking changes
  console.log('Breaking changes:', compatibility.breakingChanges);

  // 4. Update component code manually
  // (automated migration is too risky for production)

  // 5. Validate new theme
  const validation = validator.validate(newTheme, '2.0.0');
  if (!validation.valid) {
    throw new Error('New theme validation failed');
  }
}
```

---

## Implementation Plan

### Phase 1: Core Types (Week 1)

**Files to Create:**
```
domain/tokens/types/
â”œâ”€â”€ DesignIntent.types.ts       # Layer 1 types
â”œâ”€â”€ GeneratedToken.types.ts     # Layer 2 types
â”œâ”€â”€ Validation.types.ts         # Validator types
â””â”€â”€ Version.types.ts            # Versioning types
```

### Phase 2: Generator (Week 2)

**Files to Create:**
```
domain/tokens/generators/
â”œâ”€â”€ TokenThemeGenerator.ts      # Main generator
â”œâ”€â”€ StateVariantGenerator.ts    # State variant logic
â””â”€â”€ QualityAnalyzer.ts          # Quality reporting
```

### Phase 3: Validator (Week 3)

**Files to Create:**
```
domain/tokens/validators/
â”œâ”€â”€ TokenValidator.ts           # Main validator
â”œâ”€â”€ StructureValidator.ts       # Structure checks
â”œâ”€â”€ MetadataValidator.ts        # Metadata checks
â””â”€â”€ AccessibilityValidator.ts   # A11y checks
```

### Phase 4: Integration (Week 4)

**Files to Create:**
```
domain/tokens/
â”œâ”€â”€ index.ts                    # Public API
â””â”€â”€ examples/
    â”œâ”€â”€ basic-generation.ts     # Example usage
    â””â”€â”€ validation.ts           # Validation examples
```

---

## Success Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| **Tokens generated automatically** | 100% | Count manual vs generated |
| **Tokens without Momoto metadata** | 0 | Validation scan |
| **Heuristics in generator** | 0 | Code audit |
| **Silent validation failures** | 0 | Test coverage |
| **Contract violations** | 0 | Automated checks |
| **Quality threshold** | >0.8 avg | Quality report |

---

## Risks & Mitigation

### Risk 1: State Variant Generation

**Problem:** No dedicated Momoto API for state variants yet.

**Mitigation:**
- Use existing Momoto operations (lighten, darken, desaturate)
- Document amounts as constants (not heuristics)
- Full enrichment via TokenEnrichmentService
- Plan intelligent variants for future phase

### Risk 2: Performance

**Problem:** Generating complete theme requires many Momoto calls.

**Mitigation:**
- Batch token generation where possible
- Cache generated themes
- Provide progress callbacks
- Consider worker threads for large themes

### Risk 3: Version Migration

**Problem:** Breaking changes require manual updates.

**Mitigation:**
- Document all breaking changes clearly
- Provide migration guides
- Validate compatibility before deploy
- Version lock during migration

---

## Future Phases (Design Considerations)

### FASE 13: Framework Adapters

**Generator must support:**
- Export to Vue/Svelte/Angular formats
- Framework-specific optimizations
- Runtime vs build-time generation

### FASE 14: Governance & Enterprise

**Generator must support:**
- Quality gates (block low-quality themes)
- Audit logging
- Compliance reports
- Token linting

### FASE 15: CLI & DevTools

**Generator must support:**
- CLI generation workflow
- Visual token editor
- Live preview
- Browser DevTools integration

---

## Deliverables

### Code

- [ ] `DesignIntent.types.ts` - Layer 1 types
- [ ] `GeneratedToken.types.ts` - Layer 2 types
- [ ] `Validation.types.ts` - Validator types
- [ ] `TokenThemeGenerator.ts` - Main generator
- [ ] `StateVariantGenerator.ts` - State variants
- [ ] `TokenValidator.ts` - Main validator
- [ ] `examples/` - Usage examples

### Documentation

- [ ] `FASE_12_PLAN.md` - This document
- [ ] `FASE_12_CONTRACT_CHECK.md` - Compliance audit
- [ ] `FASE_12_SUMMARY.md` - Executive summary
- [ ] `TOKEN_GENERATION_GUIDE.md` - How to generate themes
- [ ] `TOKEN_VALIDATION_GUIDE.md` - How to validate themes

---

## Conclusion

FASE 12 transforms the token system from **manual** to **automated** with these guarantees:

âœ… **100% Momoto-governed** â€” All tokens from intelligence
âœ… **0% manual tokens** â€” Complete automation
âœ… **Validated before runtime** â€” No bad tokens reach components
âœ… **Fully traceable** â€” Every token has sourceDecisionId
âœ… **Version-safe** â€” Explicit migration paths

**The contract is preserved. The architecture scales.**

---

**Status:** ğŸ“‹ PLAN COMPLETE â€” Ready for implementation
**Next:** Implement TokenThemeGenerator
