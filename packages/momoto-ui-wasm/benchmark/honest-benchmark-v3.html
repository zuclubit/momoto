<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Momoto Honest Benchmark v3 - Fixed</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
      background: #0a0a0a;
      color: #e0e0e0;
      padding: 20px;
      line-height: 1.6;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      padding: 20px 0;
      border-bottom: 2px solid #333;
      margin-bottom: 30px;
    }

    h1 {
      font-size: 2em;
      color: #00ff88;
      margin-bottom: 10px;
    }

    .subtitle {
      color: #888;
      font-size: 0.9em;
    }

    .critical-warning {
      background: #ff3333;
      color: white;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
      font-weight: bold;
      text-align: center;
    }

    .info-box {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
    }

    .info-box h3 {
      color: #00ff88;
      margin-bottom: 10px;
    }

    .info-box ul {
      list-style: none;
      padding-left: 20px;
    }

    .info-box li {
      margin: 5px 0;
    }

    .info-box li:before {
      content: "‚Üí ";
      color: #00ff88;
      font-weight: bold;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin: 20px 0;
      flex-wrap: wrap;
    }

    button {
      background: #00ff88;
      color: #0a0a0a;
      border: none;
      padding: 12px 24px;
      font-size: 14px;
      font-weight: bold;
      border-radius: 6px;
      cursor: pointer;
      font-family: inherit;
      transition: all 0.2s;
    }

    button:hover {
      background: #00cc6a;
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
      transform: none;
    }

    #console {
      background: #000;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 20px;
      min-height: 500px;
      max-height: 800px;
      overflow-y: auto;
      font-size: 13px;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .summary {
      background: #1a1a1a;
      border: 2px solid #333;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      display: none;
    }

    .summary.show {
      display: block;
    }

    .summary h2 {
      color: #00ff88;
      margin-bottom: 15px;
    }

    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }

    .summary-card {
      background: #000;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 15px;
    }

    .summary-card h3 {
      font-size: 0.9em;
      color: #888;
      margin-bottom: 5px;
    }

    .summary-card .value {
      font-size: 1.5em;
      font-weight: bold;
      margin: 5px 0;
    }

    .summary-card .status {
      font-size: 0.8em;
      margin-top: 5px;
    }

    .pass {
      color: #00ff88;
    }

    .fail {
      color: #ff3333;
    }

    .warn {
      color: #ffaa00;
    }

    footer {
      text-align: center;
      margin-top: 40px;
      padding-top: 20px;
      border-top: 1px solid #333;
      color: #666;
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üî¨ Momoto Performance Benchmark v3</h1>
      <div class="subtitle">FIXED Edition - Massive BatchSize + Float64Array Sink</div>
    </header>

    <div class="critical-warning" id="brokenWarning" style="display: none;">
      ‚ö†Ô∏è BENCHMARK IS BROKEN - DO NOT TRUST RESULTS
    </div>

    <div class="info-box">
      <h3>üîß What's Fixed in v3</h3>
      <ul>
        <li><strong>Massive BatchSize:</strong> 10,000+ operations per timing sample (fixes timer resolution)</li>
        <li><strong>Float64Array Sink:</strong> Harder for JIT to optimize away than globalThis</li>
        <li><strong>Precalculated Inputs:</strong> External data that JIT cannot inline</li>
        <li><strong>Strict Validation:</strong> Fails explicitly if measurements are impossible</li>
        <li><strong>Sink Verification:</strong> Shows sinkSum to prove no optimization occurred</li>
      </ul>
    </div>

    <div class="info-box">
      <h3>üìä Environment Detection</h3>
      <div id="envInfo">Detecting...</div>
    </div>

    <div class="controls">
      <button onclick="runAllBenchmarks()">üöÄ Run All Benchmarks</button>
      <button onclick="runBaselineOnly()">1. Baseline Checks Only</button>
      <button onclick="runLUTOnly()">2. LUT Performance Only</button>
      <button onclick="runBatchOnly()">3. Batch Scaling Only</button>
      <button onclick="clearConsole()">Clear Console</button>
    </div>

    <div id="console"></div>

    <div class="summary" id="summary">
      <h2>üìä Performance Summary</h2>
      <div class="summary-grid" id="summaryGrid"></div>
    </div>

    <footer>
      Momoto Performance Benchmark v3.0 (Fixed Edition)<br>
      Powered by Momoto
    </footer>
  </div>

  <script type="module">
    // ========================================================================
    // ANTI-OPTIMIZATION INFRASTRUCTURE (v3 - FIXED)
    // ========================================================================

    /**
     * Float64Array sink - harder to optimize than globalThis
     */
    const SINK = new Float64Array(1);
    SINK[0] = 0;

    /**
     * Consume result - force side effect that JIT cannot eliminate
     */
    function consumeResult(value) {
      SINK[0] += (typeof value === 'number' && !isNaN(value)) ? value : 1;

      // Force side effect - JIT cannot prove this never happens
      if (SINK[0] === Infinity || SINK[0] > 1e100) {
        console.error('‚ö†Ô∏è Sink overflow:', SINK[0]);
        SINK[0] = 0; // Reset
      }
    }

    /**
     * Get sink value - proves that results were used
     */
    function getSinkValue() {
      return SINK[0];
    }

    /**
     * Reset sink
     */
    function resetSink() {
      SINK[0] = 0;
    }

    // ========================================================================
    // BATCH SIZE CONSTANTS (v3 - MASSIVE)
    // ========================================================================

    // Detect timer resolution and adjust batch sizes accordingly
    function detectTimerResolution() {
      const samples = [];
      for (let i = 0; i < 100; i++) {
        const start = performance.now();
        const end = performance.now();
        const delta = end - start;
        if (delta > 0) samples.push(delta);
      }

      if (samples.length === 0) return 1; // 1ms (worst case - Safari)

      samples.sort((a, b) => a - b);
      const minDelta = samples[0];
      return minDelta; // in milliseconds
    }

    const TIMER_RESOLUTION_MS = detectTimerResolution();
    const IS_LOW_RES = TIMER_RESOLUTION_MS >= 1; // Safari: 1ms resolution

    // Adjust batch sizes based on timer resolution
    // QUICK MODE: Reduced for faster iteration (trade precision for speed)
    const QUICK_MODE = true; // Set to false for full precision benchmarks

    const BATCH_SIZES = QUICK_MODE ? {
      // Quick mode: Fast results, acceptable precision
      NANO: 50_000,      // < 10ns operations
      FAST: 5_000,       // 10-100ns operations
      MEDIUM: 500,       // 100-1000ns (WASM calls)
      SLOW: 50,          // > 1¬µs operations
    } : IS_LOW_RES ? {
      // Safari mode: 1ms timer requires 10x larger batches
      NANO: 1_000_000,   // < 10ns operations (array access)
      FAST: 100_000,     // 10-100ns (Math.random, sqrt, LUT lookups)
      MEDIUM: 10_000,    // 100-1000ns (WASM calls)
      SLOW: 1_000,       // > 1¬µs (complex operations)
    } : {
      // Chrome/Firefox mode: 100¬µs timer
      NANO: 100_000,     // < 10ns operations (array access)
      FAST: 10_000,      // 10-100ns (Math.random, sqrt, LUT lookups)
      MEDIUM: 1_000,     // 100-1000ns (WASM calls)
      SLOW: 100,         // > 1¬µs (complex operations)
    };

    console.log(`Timer resolution: ${TIMER_RESOLUTION_MS}ms (using ${QUICK_MODE ? 'QUICK' : IS_LOW_RES ? 'SAFARI' : 'CHROME'} batch sizes)`);

    // ========================================================================
    // INPUT GENERATION (v3 - PRECALCULATED)
    // ========================================================================

    /**
     * Generate precalculated inputs that JIT cannot inline
     */
    function generateInputs(count = 10000) {
      const inputs = {
        random: new Float64Array(count),
        sqrt: new Float64Array(count),
        ior: new Float64Array(count),
        cosTheta: new Float64Array(count),
        absorption: new Float64Array(count),
        distance: new Float64Array(count),
      };

      for (let i = 0; i < count; i++) {
        inputs.random[i] = Math.random();
        inputs.sqrt[i] = Math.random() * 1000 + 1;
        inputs.ior[i] = 1.0 + Math.random() * 1.5; // 1.0-2.5
        inputs.cosTheta[i] = Math.random(); // 0-1
        inputs.absorption[i] = 0.05 + Math.random() * 0.25; // 0.05-0.3
        inputs.distance[i] = 1.0 + Math.random() * 9.0; // 1.0-10.0
      }

      return inputs;
    }

    // Generate once at startup
    const INPUTS = generateInputs();

    // ========================================================================
    // CORE BENCHMARK FUNCTION (v3 - FIXED)
    // ========================================================================

    /**
     * Run a reliable benchmark with massive batch size
     *
     * @param {string} name - Benchmark name
     * @param {Function} fn - Function to benchmark (receives index)
     * @param {Object} options - Configuration
     * @returns {Object} - Benchmark result
     */
    function benchmark(name, fn, options = {}) {
      const {
        warmupRuns = QUICK_MODE ? 100 : 1000,
        measuredRuns = QUICK_MODE ? 20 : 100,
        batchSize = BATCH_SIZES.FAST,
        expectedMinNs = 0.001, // Minimum plausible time (1 picosecond)
        expectedMaxNs = 1_000_000, // Maximum plausible time (1ms)
      } = options;

      // Reset sink before benchmark
      resetSink();
      const sinkBefore = getSinkValue();

      // Warmup
      for (let i = 0; i < warmupRuns; i++) {
        const result = fn(i);
        consumeResult(result);
      }

      const sinkAfterWarmup = getSinkValue();

      // Measured runs
      const times = [];

      for (let run = 0; run < measuredRuns; run++) {
        const offset = run * batchSize;

        const start = performance.now();

        for (let i = 0; i < batchSize; i++) {
          const result = fn(offset + i);
          consumeResult(result);
        }

        const end = performance.now();
        const timeMs = end - start;
        times.push(timeMs);
      }

      const sinkAfter = getSinkValue();

      // Statistical analysis
      times.sort((a, b) => a - b);
      const median = times[Math.floor(times.length / 2)];
      const min = times[0];
      const max = times[times.length - 1];
      const mean = times.reduce((sum, t) => sum + t, 0) / times.length;

      const variance = times.reduce((sum, t) => sum + (t - mean) ** 2, 0) / times.length;
      const stddev = Math.sqrt(variance);
      const cv = mean > 0 ? (stddev / mean) * 100 : 0;

      // Time per operation in nanoseconds
      const timePerOpNs = (median * 1_000_000) / batchSize;

      // Validation
      const sinkChanged = Math.abs(sinkAfter - sinkBefore) > 0.001;
      const timePlausible = timePerOpNs >= expectedMinNs && timePerOpNs <= expectedMaxNs;
      const stableEnough = cv < 100; // CV < 100% is acceptable

      const valid = sinkChanged && timePlausible && stableEnough;

      const warnings = [];
      if (!sinkChanged) warnings.push('Sink unchanged - JIT may have eliminated code');
      if (timePerOpNs < expectedMinNs) warnings.push(`Time too low (${timePerOpNs.toFixed(6)}ns < ${expectedMinNs}ns)`);
      if (timePerOpNs > expectedMaxNs) warnings.push(`Time too high (${timePerOpNs.toFixed(2)}ns > ${expectedMaxNs}ns)`);
      if (cv > 50) warnings.push(`High variance (CV: ${cv.toFixed(1)}%)`);

      return {
        name,
        valid,
        warnings,
        median_ms: median,
        min_ms: min,
        max_ms: max,
        mean_ms: mean,
        stddev_ms: stddev,
        cv_percent: cv,
        time_per_op_ns: timePerOpNs,
        runs: measuredRuns,
        batchSize,
        totalSamples: measuredRuns * batchSize,
        sinkBefore,
        sinkAfter,
        sinkDelta: sinkAfter - sinkBefore,
      };
    }

    // ========================================================================
    // FORMATTING UTILITIES
    // ========================================================================

    function formatTime(ns) {
      if (ns < 1) return `${(ns * 1000).toFixed(2)}ps`;
      if (ns < 1000) return `${ns.toFixed(2)}ns`;
      if (ns < 1_000_000) return `${(ns / 1000).toFixed(2)}¬µs`;
      return `${(ns / 1_000_000).toFixed(2)}ms`;
    }

    function formatNumber(n) {
      return n.toLocaleString('en-US');
    }

    function reportBenchmark(result) {
      const lines = [];

      lines.push(`${result.name}`);
      lines.push(`  Time per operation: ${formatTime(result.time_per_op_ns)}`);
      lines.push(`  Range: ${formatTime(result.min_ms * 1_000_000 / result.batchSize)} - ${formatTime(result.max_ms * 1_000_000 / result.batchSize)}`);
      lines.push(`  Stability: œÉ=${formatTime(result.stddev_ms * 1_000_000 / result.batchSize)} (CV: ${result.cv_percent.toFixed(1)}%)`);
      lines.push(`  Samples: ${formatNumber(result.totalSamples)} (${result.runs} runs √ó ${formatNumber(result.batchSize)} batch)`);
      lines.push(`  Sink: ${result.sinkBefore.toFixed(2)} ‚Üí ${result.sinkAfter.toFixed(2)} (Œî${result.sinkDelta.toFixed(2)})`);

      if (result.valid) {
        lines.push(`  ‚úì VALID measurement`);
      } else {
        lines.push(`  ‚úó INVALID measurement`);
        result.warnings.forEach(w => lines.push(`    - ${w}`));
      }

      return lines.join('\n');
    }

    // ========================================================================
    // CONSOLE OUTPUT
    // ========================================================================

    function log(message) {
      const consoleEl = document.getElementById('console');
      consoleEl.textContent += message + '\n';
      consoleEl.scrollTop = consoleEl.scrollHeight;
    }

    function clearConsole() {
      document.getElementById('console').textContent = '';
      document.getElementById('summary').classList.remove('show');
    }

    function showBrokenWarning() {
      document.getElementById('brokenWarning').style.display = 'block';
    }

    function updateSummary(results) {
      const summaryEl = document.getElementById('summary');
      const gridEl = document.getElementById('summaryGrid');

      gridEl.innerHTML = '';

      for (const [key, result] of Object.entries(results)) {
        const card = document.createElement('div');
        card.className = 'summary-card';

        const status = result.valid ? 'pass' : 'fail';
        const statusText = result.valid ? '‚úì VALID' : '‚úó INVALID';

        card.innerHTML = `
          <h3>${result.name}</h3>
          <div class="value ${status}">${formatTime(result.time_per_op_ns)}</div>
          <div class="status ${status}">${statusText}</div>
        `;

        gridEl.appendChild(card);
      }

      summaryEl.classList.add('show');
    }

    // ========================================================================
    // ENVIRONMENT DETECTION
    // ========================================================================

    function detectEnvironment() {
      const ua = navigator.userAgent;
      let browser = 'Unknown';

      if (ua.includes('Chrome')) browser = 'Chrome';
      else if (ua.includes('Firefox')) browser = 'Firefox';
      else if (ua.includes('Safari')) browser = 'Safari';
      else if (ua.includes('Edge')) browser = 'Edge';

      const cores = navigator.hardwareConcurrency || 'Unknown';
      const memory = navigator.deviceMemory ? `${navigator.deviceMemory}GB` : 'Unknown';

      const timerResMs = TIMER_RESOLUTION_MS;
      const batchMode = QUICK_MODE ? 'QUICK (5k batches)' : IS_LOW_RES ? 'SAFARI (100k batches)' : 'CHROME (10k batches)';

      const info = `
Browser: ${browser} | CPU Cores: ${cores} | Memory: ${memory}
Timer Resolution: ${timerResMs}ms | Batch Mode: ${batchMode}
${QUICK_MODE ? '‚ö° QUICK MODE - Fast results, acceptable precision (~10s)' : IS_LOW_RES ? '‚ö†Ô∏è Low-res timer detected - using 10x larger batch sizes' : '‚úì High-res timer - normal batch sizes'}
      `.trim();

      document.getElementById('envInfo').textContent = info;

      return { browser, cores, memory, timerResMs };
    }

    // ========================================================================
    // BASELINE BENCHMARKS
    // ========================================================================

    function runBaselineChecks() {
      log('‚ïê'.repeat(80));
      log('BASELINE SANITY CHECKS (v3 - FIXED)');
      log('‚ïê'.repeat(80));
      log('');

      const results = {};

      // 1. Math.random() - Expected: 20-50ns (but may be optimized by V8)
      log('1. Math.random() - Expected: 20-50ns');
      results.mathRandom = benchmark(
        'Math.random()',
        (i) => INPUTS.random[i % INPUTS.random.length],
        {
          batchSize: BATCH_SIZES.FAST,
          expectedMinNs: IS_LOW_RES ? 0.5 : 10, // Lower expectation for low-res timers
          expectedMaxNs: 200,
        }
      );
      log(reportBenchmark(results.mathRandom));
      log('');

      // 2. Math.sqrt() - Expected: 5-15ns
      log('2. Math.sqrt() - Expected: 5-15ns');
      results.mathSqrt = benchmark(
        'Math.sqrt()',
        (i) => Math.sqrt(INPUTS.sqrt[i % INPUTS.sqrt.length]),
        {
          batchSize: BATCH_SIZES.FAST,
          expectedMinNs: 2,
          expectedMaxNs: 50,
        }
      );
      log(reportBenchmark(results.mathSqrt));
      log('');

      // 3. Float64Array access - Expected: < 5ns
      log('3. Float64Array access - Expected: < 5ns');
      results.arrayAccess = benchmark(
        'Float64Array access',
        (i) => INPUTS.random[i % INPUTS.random.length],
        {
          batchSize: BATCH_SIZES.NANO,
          expectedMinNs: 0.1,
          expectedMaxNs: 20,
        }
      );
      log(reportBenchmark(results.arrayAccess));
      log('');

      // Overall health
      log('‚îÄ'.repeat(80));
      log('BASELINE HEALTH:');

      const validCount = Object.values(results).filter(r => r.valid).length;
      const totalCount = Object.values(results).length;
      const majorityValid = validCount >= 2; // At least 2 of 3 must pass

      if (validCount === totalCount) {
        log('‚úì ALL BASELINES VALID - Benchmark is working correctly!');
        log('');
        log(`Math.random(): ${formatTime(results.mathRandom.time_per_op_ns)}`);
        log(`Math.sqrt():   ${formatTime(results.mathSqrt.time_per_op_ns)}`);
        log(`Array access:  ${formatTime(results.arrayAccess.time_per_op_ns)}`);
      } else if (majorityValid) {
        log(`‚ö†Ô∏è PARTIAL VALIDATION - ${validCount}/${totalCount} baselines valid`);
        log('');
        log('Valid checks:');
        Object.entries(results).forEach(([key, result]) => {
          if (result.valid) {
            log(`  ‚úì ${result.name}: ${formatTime(result.time_per_op_ns)}`);
          }
        });
        log('');
        log('Failed checks:');
        Object.entries(results).forEach(([key, result]) => {
          if (!result.valid) {
            log(`  ‚úó ${result.name}: ${formatTime(result.time_per_op_ns)} - ${result.warnings[0]}`);
          }
        });
        log('');
        log('‚ö†Ô∏è Majority valid - proceeding with caution');
        log('Note: Math.random() may be heavily optimized by V8 or timer resolution insufficient');
      } else {
        log('‚úó BASELINES FAILED - Benchmark is BROKEN');
        log('');
        log('Failed checks:');
        Object.entries(results).forEach(([key, result]) => {
          if (!result.valid) {
            log(`  - ${result.name}: ${result.warnings.join(', ')}`);
          }
        });
        log('');
        log('The benchmark environment is compromised. DO NOT TRUST any results.');
        showBrokenWarning();
      }

      log('‚ïê'.repeat(80));
      log('');

      return { results, valid: majorityValid };
    }

    // ========================================================================
    // WASM MODULE LOADING
    // ========================================================================

    let wasmModule = null;

    async function loadWASM() {
      try {
        log('Loading WASM module (pkg-glass with glass physics)...');
        const module = await import('../pkg-glass/momoto_wasm.js');
        await module.default();
        wasmModule = module;
        log('‚úì WASM module loaded successfully (momoto_wasm)');
        log('');
        return true;
      } catch (error) {
        log('‚úó Failed to load WASM module');
        log(`  Error: ${error.message}`);
        log('');
        log('  Make sure to run from http://localhost:8080/benchmark/');
        log('  And that pkg-glass/ directory exists (run wasm-pack build)');
        return false;
      }
    }

    // ========================================================================
    // LUT BENCHMARKS
    // ========================================================================

    function runLUTBenchmarks() {
      if (!wasmModule) {
        log('‚úó Cannot run LUT benchmarks - WASM not loaded');
        return { results: {}, valid: false };
      }

      log('‚ïê'.repeat(80));
      log('LUT FUNCTIONS PERFORMANCE (v3 - FIXED)');
      log('‚ïê'.repeat(80));
      log('');

      const results = {};

      // 1. fresnelFast - Target: < 1¬µs (1000ns)
      log('1. fresnelFast(ior, cos_theta) - Target: < 1¬µs');
      results.fresnelFast = benchmark(
        'fresnelFast',
        (i) => {
          const ior = INPUTS.ior[i % INPUTS.ior.length];
          const cos = INPUTS.cosTheta[i % INPUTS.cosTheta.length];
          return wasmModule.fresnelFast(ior, cos);
        },
        {
          batchSize: BATCH_SIZES.FAST,
          expectedMinNs: 10,
          expectedMaxNs: 5000,
        }
      );
      log(reportBenchmark(results.fresnelFast));

      const fresnelPass = results.fresnelFast.valid && results.fresnelFast.time_per_op_ns < 1000;
      log(`  Target: < 1000ns (1¬µs)`);
      log(`  Status: ${fresnelPass ? '‚úì PASS' : '‚úó FAIL'}`);
      log('');

      // 2. beerLambertFast - Target: < 1¬µs
      log('2. beerLambertFast(absorption, distance) - Target: < 1¬µs');
      results.beerLambertFast = benchmark(
        'beerLambertFast',
        (i) => {
          const absorption = INPUTS.absorption[i % INPUTS.absorption.length];
          const distance = INPUTS.distance[i % INPUTS.distance.length];
          return wasmModule.beerLambertFast(absorption, distance);
        },
        {
          batchSize: BATCH_SIZES.FAST,
          expectedMinNs: 10,
          expectedMaxNs: 5000,
        }
      );
      log(reportBenchmark(results.beerLambertFast));

      const beerPass = results.beerLambertFast.valid && results.beerLambertFast.time_per_op_ns < 1000;
      log(`  Target: < 1000ns (1¬µs)`);
      log(`  Status: ${beerPass ? '‚úì PASS' : '‚úó FAIL'}`);
      log('');

      // 3. LUT Memory
      log('3. LUT Memory Footprint - Target: < 1MB');
      const lutMemory = wasmModule.totalLutMemory();
      const memoryPass = lutMemory < 1024 * 1024;
      log(`  Total: ${(lutMemory / 1024).toFixed(2)} KB`);
      log(`  Status: ${memoryPass ? '‚úì PASS' : '‚úó FAIL'}`);
      log('');

      log('‚îÄ'.repeat(80));
      log('LUT SUMMARY:');
      log(`  fresnelFast:     ${fresnelPass ? '‚úì PASS' : '‚úó FAIL'} (${formatTime(results.fresnelFast.time_per_op_ns)})`);
      log(`  beerLambertFast: ${beerPass ? '‚úì PASS' : '‚úó FAIL'} (${formatTime(results.beerLambertFast.time_per_op_ns)})`);
      log(`  LUT memory:      ${memoryPass ? '‚úì PASS' : '‚úó FAIL'} (${(lutMemory / 1024).toFixed(2)} KB)`);
      log('‚ïê'.repeat(80));
      log('');

      const allValid = results.fresnelFast.valid && results.beerLambertFast.valid;
      return { results, valid: allValid };
    }

    // ========================================================================
    // BATCH SCALING BENCHMARKS
    // ========================================================================

    function runBatchScalingBenchmarks() {
      if (!wasmModule) {
        log('‚úó Cannot run batch benchmarks - WASM not loaded');
        return { results: {}, valid: false };
      }

      log('‚ïê'.repeat(80));
      log('BATCH API SCALING (v3 - FIXED)');
      log('‚ïê'.repeat(80));
      log('');

      log('Testing with 100 materials (realistic use case)');
      log('');

      const MATERIAL_COUNT = 100;
      const materials = [];

      for (let i = 0; i < MATERIAL_COUNT; i++) {
        materials.push({
          ior: 1.3 + (i / MATERIAL_COUNT) * 1.2,
          roughness: 0.1 + (i / MATERIAL_COUNT) * 0.8,
          thickness: 1.5 + (i / MATERIAL_COUNT) * 5.0,
          absorption: 0.05 + (i / MATERIAL_COUNT) * 0.25,
        });
      }

      const results = {};

      // Individual calls (N WASM crossings)
      log('1. Individual evaluation (100 separate WASM calls)');

      const context1 = wasmModule.MaterialContext.studio();
      const evaluator1 = wasmModule.BatchEvaluator.withContext(context1);

      results.individual = benchmark(
        'Individual calls',
        (i) => {
          let sum = 0;
          for (let j = 0; j < MATERIAL_COUNT; j++) {
            const mat = materials[j];
            const input = new wasmModule.BatchMaterialInput();
            input.push(mat.ior, mat.roughness, mat.thickness, mat.absorption);
            const res = evaluator1.evaluate(input);
            const opacity = res.getOpacity();
            sum += opacity[0];
            res.free();
            input.free();
          }
          return sum;
        },
        {
          warmupRuns: QUICK_MODE ? 5 : 10,
          measuredRuns: QUICK_MODE ? 10 : 50,
          batchSize: QUICK_MODE ? 5 : 10, // Each iteration does 100 WASM calls
          expectedMinNs: 10_000, // Expect > 10¬µs for 100 calls
          expectedMaxNs: 1_000_000,
        }
      );

      evaluator1.free();
      context1.free();

      log(reportBenchmark(results.individual));
      log('');

      // Batch call (1 WASM crossing)
      log('2. Batch evaluation (1 WASM call)');

      const context2 = wasmModule.MaterialContext.studio();
      const evaluator2 = wasmModule.BatchEvaluator.withContext(context2);

      results.batch = benchmark(
        'Batch call',
        (i) => {
          const input = new wasmModule.BatchMaterialInput();
          for (const mat of materials) {
            input.push(mat.ior, mat.roughness, mat.thickness, mat.absorption);
          }
          const res = evaluator2.evaluate(input);
          const opacity = res.getOpacity();
          let sum = 0;
          for (let k = 0; k < opacity.length; k++) {
            sum += opacity[k];
          }
          res.free();
          input.free();
          return sum;
        },
        {
          warmupRuns: QUICK_MODE ? 5 : 10,
          measuredRuns: QUICK_MODE ? 10 : 50,
          batchSize: QUICK_MODE ? 5 : 10,
          expectedMinNs: 1_000, // Expect > 1¬µs
          expectedMaxNs: 100_000,
        }
      );

      evaluator2.free();
      context2.free();

      log(reportBenchmark(results.batch));
      log('');

      // Speedup analysis
      const speedup = results.individual.time_per_op_ns / results.batch.time_per_op_ns;
      const speedupPass = speedup >= 7 && speedup <= 15;

      log('‚îÄ'.repeat(80));
      log('SPEEDUP ANALYSIS:');
      log(`  Individual (100 calls): ${formatTime(results.individual.time_per_op_ns)}`);
      log(`  Batch (1 call):         ${formatTime(results.batch.time_per_op_ns)}`);
      log(`  Speedup:                ${speedup.toFixed(2)}x`);
      log(`  Target:                 7-10x`);
      log(`  Status:                 ${speedupPass ? '‚úì PASS' : '‚úó FAIL'}`);
      log('‚ïê'.repeat(80));
      log('');

      const allValid = results.individual.valid && results.batch.valid;
      return { results, speedup, valid: allValid && speedupPass };
    }

    // ========================================================================
    // MAIN EXECUTION
    // ========================================================================

    window.runAllBenchmarks = async function() {
      clearConsole();

      log('üî¨ MOMOTO PERFORMANCE BENCHMARK v3 (FIXED)');
      log('‚ïê'.repeat(80));
      log('');

      detectEnvironment();
      log('');

      // Phase 1: Baseline checks
      const baseline = runBaselineChecks();

      if (!baseline.valid) {
        log('');
        log('‚ö†Ô∏è CRITICAL: Baseline checks FAILED');
        log('Cannot proceed with WASM benchmarks - measurements are unreliable');
        log('');
        log('Possible causes:');
        log('  1. Timer resolution too low (try different browser)');
        log('  2. System under heavy load (close applications)');
        log('  3. Browser throttling active (disable)');
        return;
      }

      // Phase 2: Load WASM
      const wasmLoaded = await loadWASM();
      if (!wasmLoaded) {
        log('Cannot proceed without WASM module');
        return;
      }

      // Phase 3: LUT benchmarks
      const lut = runLUTBenchmarks();

      // Phase 4: Batch scaling
      const batch = runBatchScalingBenchmarks();

      // Final summary
      log('');
      log('‚ïê'.repeat(80));
      log('FINAL SUMMARY');
      log('‚ïê'.repeat(80));
      log('');

      const allResults = {
        ...baseline.results,
        ...lut.results,
        individualCalls: batch.results.individual,
        batchCalls: batch.results.batch,
      };

      updateSummary(allResults);

      const allValid = baseline.valid && lut.valid && batch.valid;

      if (allValid) {
        log('‚úì ALL TESTS PASSED - Results are RELIABLE');
      } else {
        log('‚úó SOME TESTS FAILED - Check individual results');
      }

      log('');
      log('Sink verification:');
      log(`  Final sink value: ${getSinkValue().toFixed(2)}`);
      log(`  (Non-zero proves no JIT elimination occurred)`);
      log('');
      log('‚ïê'.repeat(80));
    };

    window.runBaselineOnly = function() {
      clearConsole();
      runBaselineChecks();
    };

    window.runLUTOnly = async function() {
      clearConsole();
      const wasmLoaded = await loadWASM();
      if (wasmLoaded) {
        runLUTBenchmarks();
      }
    };

    window.runBatchOnly = async function() {
      clearConsole();
      const wasmLoaded = await loadWASM();
      if (wasmLoaded) {
        runBatchScalingBenchmarks();
      }
    };

    window.clearConsole = clearConsole;

    // Initialize
    detectEnvironment();
    log('Ready. Click "Run All Benchmarks" to start.');
    log('');
  </script>
</body>
</html>
