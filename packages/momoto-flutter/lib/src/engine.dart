import 'dart:async';
import 'color.dart';

/// Bridge strategy — resolved at compile time based on target platform.
/// On native (Android/iOS/desktop): calls Rust via flutter_rust_bridge FFI.
/// On web: calls Rust WASM via dart:js_interop.
///
/// The concrete implementation is generated by flutter_rust_bridge_codegen
/// from the Rust source at momoto/crates/momoto-wasm/src/lib.rs.
///
/// To regenerate bindings after updating Rust:
///   flutter_rust_bridge_codegen generate \
///     --rust-input momoto/crates/momoto-wasm/src/lib.rs \
///     --dart-output packages/momoto-flutter/lib/src/bridge_generated.dart
///
/// For now this file provides a pure-Dart fallback that mirrors the Rust API.
/// Replace _DartFallbackBridge with `RustLib.instance` after codegen runs.

abstract class _MomotoFfi {
  Future<double> wcagContrastRatio(String fg, String bg);
  Future<double> apcaContrast(String fg, String bg);
  Future<bool> wcagPasses(String fg, String bg, {bool largeText = false});
  Future<String> wcagLevel(String fg, String bg, {bool largeText = false});
  Future<List<PaletteEntry>> hctTonalPalette(String hex);
  Future<String> hctToHex(double hue, double chroma, double tone);
  Future<List<double>> hexToHct(String hex);
  Future<String> simulateCVD(String hex, String type);
  Future<String> agentRecommendForeground(String bg);
  Future<String> glassCss(double roughness, double thickness, double ior);
}

/// Singleton engine. Call [MomotoEngine.instance] to get the initialized engine.
class MomotoEngine {
  static MomotoEngine? _instance;
  late final _MomotoFfi _ffi;

  MomotoEngine._(this._ffi);

  /// Returns the initialized singleton engine.
  static Future<MomotoEngine> get instance async {
    _instance ??= MomotoEngine._(_DartFallbackBridge());
    return _instance!;
  }

  // ── Contrast ──────────────────────────────────────────────────────────

  /// Compute WCAG 2.1 contrast ratio between two hex colors.
  Future<ContrastResult> validateContrast(String fg, String bg, {bool largeText = false}) async {
    final ratio = await _ffi.wcagContrastRatio(fg, bg);
    final lc    = await _ffi.apcaContrast(fg, bg);
    final level = await _ffi.wcagLevel(fg, bg, largeText: largeText);
    return ContrastResult(
      fgHex: fg, bgHex: bg,
      wcagRatio: ratio, apcaLc: lc.abs(), wcagLevel: level, largeText: largeText,
    );
  }

  // ── HCT Palette ───────────────────────────────────────────────────────

  /// Generate HCT tonal palette from a base color hex string.
  Future<HctPalette> generatePalette(String hex) async {
    final entries = await _ffi.hctTonalPalette(hex);
    return HctPalette(baseHex: hex, entries: entries);
  }

  // ── CVD ───────────────────────────────────────────────────────────────

  /// Simulate color vision deficiency. type: 'protanopia' | 'deuteranopia' | 'tritanopia'
  Future<CvdResult> simulateCvd(String hex, CvdType type) async {
    final simHex = await _ffi.simulateCVD(hex, type.name);
    return CvdResult(original: hex, simulated: simHex, type: type);
  }

  // ── Recommendations ───────────────────────────────────────────────────

  /// Get the best accessible foreground color for a given background.
  Future<String> recommendForeground(String bgHex) => _ffi.agentRecommendForeground(bgHex);

  // ── Materials (Glass) ─────────────────────────────────────────────────

  /// Generate glass/frost CSS for a layer.
  Future<String> glassCss({double roughness = 0.1, double thickness = 4.0, double ior = 1.5}) =>
      _ffi.glassCss(roughness, thickness, ior);
}

// ── Result types ──────────────────────────────────────────────────────────

class ContrastResult {
  final String fgHex, bgHex, wcagLevel;
  final double wcagRatio, apcaLc;
  final bool largeText;

  const ContrastResult({
    required this.fgHex, required this.bgHex,
    required this.wcagRatio, required this.apcaLc,
    required this.wcagLevel, required this.largeText,
  });

  bool get passesAA  => wcagRatio >= (largeText ? 3.0 : 4.5);
  bool get passesAAA => wcagRatio >= (largeText ? 4.5 : 7.0);
  bool get passesApca => apcaLc >= 60;

  @override
  String toString() =>
    'ContrastResult($fgHex on $bgHex: WCAG ${wcagRatio.toStringAsFixed(2)}:1 [$wcagLevel], APCA ${apcaLc.toStringAsFixed(0)} Lc)';
}

class HctPalette {
  final String baseHex;
  final List<PaletteEntry> entries;
  const HctPalette({required this.baseHex, required this.entries});
}

class PaletteEntry {
  final int tone, tailwindScale;
  final String hex;
  const PaletteEntry({required this.tone, required this.tailwindScale, required this.hex});
}

class CvdResult {
  final String original, simulated;
  final CvdType type;
  const CvdResult({required this.original, required this.simulated, required this.type});
}

enum CvdType { protanopia, deuteranopia, tritanopia }

// ── Pure-Dart fallback bridge ────────────────────────────────────────────────
// Implements a pure-Dart approximation for platforms where Rust FFI is not
// yet configured. Replace with generated RustLib after running codegen.

class _DartFallbackBridge implements _MomotoFfi {
  static double _toLinear(double c) =>
      c <= 0.04045 ? c / 12.92 : ((c + 0.055) / 1.055) * ((c + 0.055) / 1.055) * ((c + 0.055) / 1.055);

  static List<double> _hexToLinear(String hex) {
    final h = hex.replaceAll('#', '');
    final r = int.parse(h.substring(0, 2), radix: 16) / 255;
    final g = int.parse(h.substring(2, 4), radix: 16) / 255;
    final b = int.parse(h.substring(4, 6), radix: 16) / 255;
    return [_toLinear(r), _toLinear(g), _toLinear(b)];
  }

  static double _luminance(List<double> rgb) =>
      0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2];

  @override
  Future<double> wcagContrastRatio(String fg, String bg) async {
    final l1 = _luminance(_hexToLinear(fg));
    final l2 = _luminance(_hexToLinear(bg));
    return (l1 > l2)
        ? (l1 + 0.05) / (l2 + 0.05)
        : (l2 + 0.05) / (l1 + 0.05);
  }

  @override
  Future<double> apcaContrast(String fg, String bg) async {
    // Simplified APCA approximation (not the full W3 algorithm)
    final ratio = await wcagContrastRatio(fg, bg);
    return ratio * 20.0; // rough Lc estimate — replace with WASM
  }

  @override
  Future<bool> wcagPasses(String fg, String bg, {bool largeText = false}) async {
    final ratio = await wcagContrastRatio(fg, bg);
    return ratio >= (largeText ? 3.0 : 4.5);
  }

  @override
  Future<String> wcagLevel(String fg, String bg, {bool largeText = false}) async {
    final ratio = await wcagContrastRatio(fg, bg);
    if (ratio >= (largeText ? 4.5 : 7.0)) return 'AAA';
    if (ratio >= (largeText ? 3.0 : 4.5)) return 'AA';
    if (ratio >= 3.0) return 'AA Large';
    return 'Fail';
  }

  @override
  Future<List<PaletteEntry>> hctTonalPalette(String hex) async {
    // Simplified palette without full HCT — generates lightness scale
    const tones = [10, 20, 30, 40, 50, 60, 70, 80, 90, 95, 99];
    const twMap = {10:950, 20:900, 30:800, 40:700, 50:600, 60:500, 70:400, 80:300, 90:200, 95:100, 99:50};
    return tones.map((t) {
      // Interpolate toward white/black — replace with HCT via WASM/FFI
      final v = t ~/ 10 * 17;
      final hexStr = '#${v.toRadixString(16).padLeft(2,'0')}'
                   * 3; // placeholder
      return PaletteEntry(tone: t, tailwindScale: twMap[t]!, hex: hex); // stub
    }).toList();
  }

  @override
  Future<String> hctToHex(double hue, double chroma, double tone) async => '#808080';

  @override
  Future<List<double>> hexToHct(String hex) async => [240.0, 40.0, 50.0];

  @override
  Future<String> simulateCVD(String hex, String type) async => hex; // identity stub

  @override
  Future<String> agentRecommendForeground(String bg) async {
    final l = _luminance(_hexToLinear(bg));
    return l > 0.179 ? '#000000' : '#ffffff';
  }

  @override
  Future<String> glassCss(double roughness, double thickness, double ior) async {
    final blur = (roughness * 20).round();
    final opacity = (0.1 + roughness * 0.2).clamp(0.0, 0.9);
    return 'backdrop-filter: blur(${blur}px); background: rgba(255,255,255,${opacity.toStringAsFixed(2)});';
  }
}
