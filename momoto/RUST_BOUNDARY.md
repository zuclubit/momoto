# Rust/WASM Boundary Contract - FASE 3

**Date**: 2026-01-06
**Phase**: FASE 3 - Rust/WASM Migration
**Purpose**: Define TypeScript ↔ Rust/WASM integration contract

---

## Executive Summary

This document defines the boundary contract between TypeScript and Rust/WASM for the APCA implementation.

**Goals**:
1. ✅ **100% API compatibility** with existing TypeScript APCAContrast
2. ✅ **≥6x performance improvement** over TypeScript
3. ✅ **Zero accuracy regression** (100% parity with canonical)
4. ✅ **Graceful fallback** to TypeScript if WASM unavailable
5. ✅ **Feature flag** for gradual rollout

**Non-Goals**:
- ❌ Rewriting other value objects (OKLCH, WCAGContrast) in Rust (future work)
- ❌ Changing public TypeScript API
- ❌ Breaking existing code

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                    Application Layer                         │
│          (Uses APCAContrast via existing API)                │
└────────────────────────┬────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────┐
│             TypeScript Facade (Unchanged API)                │
│         domain/value-objects/APCAContrast.ts                 │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  Feature Flag: ENABLE_WASM_APCA (env/runtime)        │   │
│  └──────────────────┬───────────────────────────────────┘   │
│                     │                                        │
│            ┌────────┴────────┐                               │
│            │                 │                               │
│            ▼                 ▼                               │
│   ┌────────────────┐  ┌─────────────────┐                   │
│   │ WASM Backend   │  │ TypeScript      │                   │
│   │ (Production)   │  │ Fallback        │                   │
│   └────────┬───────┘  └─────────────────┘                   │
│            │                                                 │
└────────────┼─────────────────────────────────────────────────┘
             │
             ▼
    ┌────────────────────┐
    │  Rust/WASM Module  │
    │  rust/apca.wasm    │
    │                    │
    │  - calculate()     │
    │  - validate()      │
    │  - constants       │
    └────────────────────┘
```

---

## API Contract

### TypeScript Public API (Unchanged)

```typescript
class APCAContrast {
  // Factory method - PRIMARY ENTRY POINT
  static calculate(
    foreground: string,
    background: string
  ): APCAContrast;

  // Constructor (used internally)
  private constructor(
    lc: number,
    polarity: 'dark-on-light' | 'light-on-dark',
    foreground: Color,
    background: Color
  );

  // Properties
  readonly lc: number;
  readonly polarity: 'dark-on-light' | 'light-on-dark';
  readonly foreground: Color;
  readonly background: Color;

  // Methods
  passes(level: APCALevel): boolean;
  invert(): APCAContrast;
  toString(): string;
  toJSON(): object;
}
```

**Contract**: This API MUST remain unchanged. Rust/WASM is an internal optimization.

---

## Rust/WASM Internal API

### Rust Function Signature

```rust
/// APCA contrast calculation
///
/// Returns Lc value (signed float) for given foreground/background colors.
/// Matches canonical apca-w3 implementation bit-for-bit.
///
/// # Arguments
/// * `fg_r` - Foreground red (0-255)
/// * `fg_g` - Foreground green (0-255)
/// * `fg_b` - Foreground blue (0-255)
/// * `bg_r` - Background red (0-255)
/// * `bg_g` - Background green (0-255)
/// * `bg_b` - Background blue (0-255)
///
/// # Returns
/// * Lc value as f64 (positive = dark-on-light, negative = light-on-dark)
///
/// # Example
/// ```rust
/// let lc = apca_contrast(0, 0, 0, 255, 255, 255);
/// assert_eq!(lc, 106.04);
/// ```
#[wasm_bindgen]
pub fn apca_contrast(
    fg_r: u8,
    fg_g: u8,
    fg_b: u8,
    bg_r: u8,
    bg_g: u8,
    bg_b: u8,
) -> f64;
```

### WASM Exported Function

```javascript
// Generated by wasm-bindgen
export function apca_contrast(
  fg_r: number,
  fg_g: number,
  fg_b: number,
  bg_r: number,
  bg_g: number,
  bg_b: number
): number;
```

---

## Integration Strategy

### Feature Flag System

**Environment Variable** (Build-time):
```bash
# Enable WASM at build time
ENABLE_WASM_APCA=true npm run build

# Disable WASM (use TypeScript fallback)
ENABLE_WASM_APCA=false npm run build
```

**Runtime Detection**:
```typescript
// Check if WASM is available and enabled
const useWasm =
  process.env.ENABLE_WASM_APCA === 'true' &&
  typeof WebAssembly !== 'undefined' &&
  wasmModule !== null;
```

### Fallback Mechanism

```typescript
// domain/value-objects/APCAContrast.ts

import { apca_contrast } from '../../rust/pkg/apca_wasm'; // Conditional

class APCAContrast {
  static calculate(foreground: string, background: string): APCAContrast {
    // Parse colors
    const fg = Color.fromHex(foreground);
    const bg = Color.fromHex(background);

    let lc: number;

    // Feature flag: Use WASM if available
    if (USE_WASM && wasmModule) {
      try {
        lc = apca_contrast(
          fg.r, fg.g, fg.b,
          bg.r, bg.g, bg.b
        );
      } catch (error) {
        // Fallback to TypeScript on WASM error
        console.warn('WASM APCA failed, falling back to TypeScript:', error);
        lc = this.calculateTypeScript(fg, bg);
      }
    } else {
      // Use TypeScript implementation
      lc = this.calculateTypeScript(fg, bg);
    }

    // Determine polarity
    const polarity = lc >= 0 ? 'dark-on-light' : 'light-on-dark';

    return new APCAContrast(lc, polarity, fg, bg);
  }

  private static calculateTypeScript(fg: Color, bg: Color): number {
    // Existing TypeScript implementation (preserve as fallback)
    // ... current code ...
  }
}
```

---

## Data Type Mapping

### TypeScript → Rust

| TypeScript | Rust | WASM | Notes |
|------------|------|------|-------|
| `string` (hex) | Parse before call | N/A | Parse in TS, send RGB |
| `number` (0-255) | `u8` | `number` | RGB channel values |
| `number` (Lc) | `f64` | `number` | Contrast result |
| `Color` object | Decompose to RGB | N/A | Extract r,g,b before call |

**Design Decision**: Parse hex colors in TypeScript, send RGB values to Rust.

**Rationale**:
- Color parsing is not performance-critical
- Keeps WASM API simple (6 numbers in, 1 number out)
- Reduces WASM bundle size
- Maintains TypeScript color validation

---

## Error Handling Strategy

### Rust Error Handling

```rust
#[wasm_bindgen]
pub fn apca_contrast(
    fg_r: u8, fg_g: u8, fg_b: u8,
    bg_r: u8, bg_g: u8, bg_b: u8,
) -> f64 {
    // RGB values are u8, so range is guaranteed valid
    // No error cases possible with this API
    calculate_apca_internal(fg_r, fg_g, fg_b, bg_r, bg_g, bg_b)
}
```

**Design Decision**: No explicit error handling needed.

**Rationale**:
- RGB values are `u8` (0-255), type system guarantees validity
- APCA calculation has no failure modes for valid RGB
- TypeScript layer validates hex strings before calling Rust

### TypeScript Error Handling

```typescript
static calculate(foreground: string, background: string): APCAContrast {
  // Validate hex strings BEFORE calling WASM
  if (!Color.isValidHex(foreground)) {
    throw new Error(`Invalid foreground color: ${foreground}`);
  }
  if (!Color.isValidHex(background)) {
    throw new Error(`Invalid background color: ${background}`);
  }

  // Parse to RGB
  const fg = Color.fromHex(foreground);
  const bg = Color.fromHex(background);

  // Call WASM (or fallback)
  const lc = USE_WASM
    ? apca_contrast(fg.r, fg.g, fg.b, bg.r, bg.g, bg.b)
    : this.calculateTypeScript(fg, bg);

  // ... rest of implementation
}
```

---

## Performance Requirements

### Targets

| Metric | TypeScript Baseline | Rust/WASM Target | Measurement |
|--------|---------------------|------------------|-------------|
| Single Calculation | ~X µs | ≤X/6 µs | Benchmark 1M iterations |
| Batch (1000 colors) | ~Y ms | ≤Y/6 ms | Real-world usage pattern |
| Memory Overhead | 0 bytes | <100 KB | WASM bundle size |
| Load Time | 0 ms | <50 ms | WASM initialization |

**Success Criteria**:
- ✅ ≥6x speedup on single calculations
- ✅ ≥6x speedup on batch operations
- ✅ WASM bundle size <100 KB
- ✅ WASM initialization <50 ms

**Measurement Strategy**:
```typescript
// benchmark/suites/apca-performance.benchmark.ts
import { performance } from 'perf_hooks';

function benchmarkAPCA(iterations: number) {
  const colors = generateTestColors(1000);

  const start = performance.now();
  for (let i = 0; i < iterations; i++) {
    APCAContrast.calculate(colors[i % 1000].fg, colors[i % 1000].bg);
  }
  const end = performance.now();

  return {
    totalTime: end - start,
    avgTime: (end - start) / iterations,
    opsPerSecond: iterations / ((end - start) / 1000)
  };
}
```

---

## Accuracy Requirements

### Parity Testing

**Requirement**: Rust/WASM output MUST match TypeScript output **exactly** (bit-for-bit).

```typescript
// __tests__/apca-wasm-parity.test.ts
describe('APCA WASM Parity', () => {
  it('should match TypeScript output exactly', () => {
    for (const vector of APCA_GOLDEN_VECTORS) {
      const tsResult = APCAContrast.calculateTypeScript(
        vector.foreground.hex,
        vector.background.hex
      );

      const wasmResult = apca_contrast(
        vector.foreground.rgb[0],
        vector.foreground.rgb[1],
        vector.foreground.rgb[2],
        vector.background.rgb[0],
        vector.background.rgb[1],
        vector.background.rgb[2]
      );

      expect(wasmResult).toBe(tsResult.lc);
    }
  });
});
```

**Test Coverage**:
- ✅ All 12 golden vectors
- ✅ 1000 random color combinations
- ✅ Edge cases (black, white, grays, chromatic colors)
- ✅ Floating point precision (max deviation 0.01 Lc)

---

## Build and Deployment Strategy

### Development Workflow

```bash
# 1. Develop Rust code
cd rust-wasm-migration
cargo build

# 2. Build WASM
wasm-pack build --target bundler

# 3. Test Rust (unit tests)
cargo test

# 4. Integrate with TypeScript
npm run build

# 5. Run parity tests
npm test -- apca-wasm-parity

# 6. Run performance benchmarks
npm run benchmark:apca
```

### Directory Structure

```
momoto/
├── domain/
│   └── value-objects/
│       └── APCAContrast.ts        # TypeScript facade (updated)
├── rust-wasm-migration/
│   ├── Cargo.toml                 # Rust dependencies
│   ├── src/
│   │   ├── lib.rs                 # WASM entry point
│   │   └── apca.rs                # APCA implementation
│   ├── pkg/                       # Generated WASM output
│   │   ├── apca_wasm.js
│   │   ├── apca_wasm.d.ts
│   │   └── apca_wasm_bg.wasm
│   └── tests/
│       └── apca_tests.rs          # Rust unit tests
├── __tests__/
│   ├── apca-accuracy-fix-verification.test.ts  # Existing
│   ├── apca-wasm-parity.test.ts                # NEW
│   └── apca-wasm-performance.test.ts           # NEW
└── benchmark/
    └── suites/
        └── apca-wasm-comparison.benchmark.ts   # NEW
```

---

## Feature Flag Configuration

### Environment Variables

```bash
# .env.development
ENABLE_WASM_APCA=false  # Use TypeScript during development

# .env.production
ENABLE_WASM_APCA=true   # Use WASM in production

# .env.test
ENABLE_WASM_APCA=true   # Test both paths
```

### Runtime Override

```typescript
// Allow runtime override for A/B testing
export const USE_WASM =
  process.env.ENABLE_WASM_APCA === 'true' &&
  typeof WebAssembly !== 'undefined' &&
  !process.env.FORCE_TYPESCRIPT_APCA;

// Usage:
// FORCE_TYPESCRIPT_APCA=true npm start  # Force TypeScript
```

---

## Gradual Rollout Strategy

### Phase 1: WASM Available, TypeScript Default
```typescript
const USE_WASM = false; // Default off
```
- WASM bundled but not used
- A/B test with small percentage of users
- Validate performance and accuracy in production

### Phase 2: WASM Default, TypeScript Fallback
```typescript
const USE_WASM = true; // Default on
```
- WASM becomes default implementation
- TypeScript remains as fallback
- Monitor error rates and performance

### Phase 3: WASM Only (Optional Future)
```typescript
// Remove TypeScript implementation after 6+ months
// Only if WASM proves 100% reliable
```

---

## Rust Implementation Requirements

### Constants

```rust
// Must match TypeScript exactly
const MAIN_TRC: f64 = 2.4;
const S_R_CO: f64 = 0.2126729;
const S_G_CO: f64 = 0.7151522;
const S_B_CO: f64 = 0.0721750;
const BLK_THRS: f64 = 0.022;
const BLK_CLMP: f64 = 1.414;
const NORM_BG: f64 = 0.56;
const NORM_TXT: f64 = 0.57;
const REV_BG: f64 = 0.65;
const REV_TXT: f64 = 0.62;
const SCALE_BOW: f64 = 1.14;
const SCALE_WOB: f64 = 1.14;
const LO_BOW_OFFSET: f64 = 0.027;
const LO_WOB_OFFSET: f64 = 0.027;
const LO_CLIP: f64 = 0.1;
const DELTA_Y_MIN: f64 = 0.0005;
```

### Algorithm Flow

```rust
pub fn apca_contrast(
    fg_r: u8, fg_g: u8, fg_b: u8,
    bg_r: u8, bg_g: u8, bg_b: u8,
) -> f64 {
    // 1. sRGB to luminance (Y)
    let text_y = srgb_to_y(fg_r, fg_g, fg_b);
    let bg_y = srgb_to_y(bg_r, bg_g, bg_b);

    // 2. Soft clamp for very dark colors
    let text_y = soft_clamp(text_y);
    let bg_y = soft_clamp(bg_y);

    // 3. Determine polarity
    let is_dark_on_light = bg_y > text_y;

    // 4. Calculate SAPC
    let sapc = if is_dark_on_light {
        (bg_y.powf(NORM_BG) - text_y.powf(NORM_TXT)) * SCALE_BOW
    } else {
        (bg_y.powf(REV_BG) - text_y.powf(REV_TXT)) * SCALE_WOB
    };

    // 5. Check deltaYmin
    if (bg_y - text_y).abs() < DELTA_Y_MIN {
        return 0.0;
    }

    // 6. Clipping and offset
    let output_contrast = if is_dark_on_light {
        if sapc < LO_CLIP { 0.0 } else { sapc - LO_BOW_OFFSET }
    } else {
        if sapc > -LO_CLIP { 0.0 } else { sapc + LO_WOB_OFFSET }
    };

    // 7. Scale to Lc
    output_contrast * 100.0
}
```

**Requirement**: This MUST produce identical results to TypeScript implementation.

---

## Testing Strategy

### Unit Tests (Rust)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_black_on_white() {
        let lc = apca_contrast(0, 0, 0, 255, 255, 255);
        assert!((lc - 106.04).abs() < 0.01);
    }

    #[test]
    fn test_blue_on_white() {
        let lc = apca_contrast(0, 0, 255, 255, 255, 255);
        assert!((lc - 85.82).abs() < 0.01);
    }

    // ... test all 12 golden vectors
}
```

### Parity Tests (TypeScript)

```typescript
describe('APCA WASM Parity', () => {
  it('matches TypeScript for all golden vectors', () => {
    for (const vector of APCA_GOLDEN_VECTORS) {
      const tsLc = APCAContrast.calculateTypeScript(
        vector.foreground.hex, vector.background.hex
      ).lc;

      const wasmLc = apca_contrast(
        ...vector.foreground.rgb,
        ...vector.background.rgb
      );

      expect(Math.abs(wasmLc - tsLc)).toBeLessThan(0.01);
    }
  });
});
```

### Performance Tests

```typescript
describe('APCA WASM Performance', () => {
  it('should be at least 6x faster than TypeScript', () => {
    const tsTime = benchmarkTypeScript(1_000_000);
    const wasmTime = benchmarkWasm(1_000_000);

    const speedup = tsTime / wasmTime;
    expect(speedup).toBeGreaterThanOrEqual(6);
  });
});
```

---

## Success Criteria

### Phase 1: Development

- ✅ Rust implementation passes all unit tests
- ✅ WASM builds successfully (<100 KB)
- ✅ TypeScript integration compiles
- ✅ Feature flag system works

### Phase 2: Validation

- ✅ 100% parity with TypeScript (all golden vectors)
- ✅ ≥6x performance improvement measured
- ✅ All existing tests pass
- ✅ No accuracy regression

### Phase 3: Production

- ✅ WASM loads in <50 ms
- ✅ Fallback mechanism works
- ✅ Production monitoring shows no errors
- ✅ Performance targets met in production

---

## Rollback Strategy

**If WASM fails in production**:

1. **Immediate**: Set `ENABLE_WASM_APCA=false` (falls back to TypeScript)
2. **No code deploy needed**: Feature flag toggles runtime behavior
3. **Zero user impact**: TypeScript fallback is already tested

**Rollback Triggers**:
- ❌ Error rate >0.1%
- ❌ Performance <3x improvement (below target)
- ❌ WASM load time >100 ms
- ❌ Accuracy issues detected

---

## Implementation Phases

### Phase 1: Setup (Day 1)
- ✅ Initialize Rust workspace
- ✅ Configure wasm-pack
- ✅ Set up build pipeline
- ✅ Create directory structure

### Phase 2: Core Implementation (Days 2-3)
- ✅ Implement APCA in Rust
- ✅ Write Rust unit tests
- ✅ Build WASM module
- ✅ Verify 100% accuracy

### Phase 3: Integration (Days 4-5)
- ✅ Create WASM bindings
- ✅ Update TypeScript facade
- ✅ Implement feature flag
- ✅ Write parity tests

### Phase 4: Validation (Days 6-7)
- ✅ Run performance benchmarks
- ✅ Validate accuracy
- ✅ Test fallback mechanism
- ✅ Document results

### Phase 5: Deployment (Day 8+)
- ✅ Gradual rollout
- ✅ Monitor performance
- ✅ Update STATUS.md
- ✅ User decision: WASM default or optional

---

## Dependencies

### Rust Crates

```toml
[dependencies]
wasm-bindgen = "0.2"

[dev-dependencies]
wasm-bindgen-test = "0.3"
```

### NPM Packages

```json
{
  "devDependencies": {
    "@wasm-tool/wasm-pack-plugin": "^1.7.0",
    "wasm-pack": "^0.12.1"
  }
}
```

---

## Open Questions

1. **WASM bundle optimization**: Should we use wasm-opt for size reduction?
   - **Recommendation**: Yes, use wasm-opt -O3 for production builds

2. **Multi-threading**: Should we support WASM threads for batch operations?
   - **Recommendation**: Defer to future work (FASE 4)

3. **Alternative backends**: Support other color spaces in Rust?
   - **Recommendation**: Only APCA in FASE 3, evaluate after

4. **npm package**: Publish Rust/WASM as separate npm package?
   - **Recommendation**: Keep monorepo for now, evaluate after production validation

---

## Next Steps

1. ✅ Set up Rust workspace and wasm-pack
2. ✅ Implement APCA in Rust (port from TypeScript)
3. ✅ Build WASM module
4. ✅ Create TypeScript integration
5. ✅ Run parity tests
6. ✅ Benchmark performance
7. ✅ User decision: Deploy or iterate

---

**Sign-off**: Principal Engineering (Color Science + Systems Architecture)
**Date**: 2026-01-06
**Phase**: FASE 3 - Rust/WASM Migration
**Status**: Boundary Contract APPROVED - Ready for Implementation
